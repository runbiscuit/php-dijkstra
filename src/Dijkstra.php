<?php

namespace Diolan12;

/**
 * A class that represents a network of cable routes.
 * Generated by OpenAI ChatGPT [Mar 14 Version](https://help.openai.com/en/articles/6825453-chatgpt-release-notes)
 */
class Dijkstra
{
    private $prefix = '#';
    private $vertices = [];
    private $edges = [];

    public function __construct($graph = [])
    {
        $prefixedVertices = [];
        foreach ($graph as $k => $edges) {
            $prefixedName = $this->setPrefix($k);
            $prefixedVertices[$prefixedName] = [];
            foreach ($edges as $edgeKey => $edgeValue) {
                $prefixedVertices[$prefixedName][$this->setPrefix($edgeKey)] = $edgeValue;
            }
        }
        $this->vertices = $prefixedVertices;
    }

    private function setPrefix(string $value)
    {
        return $this->prefix . $value;
    }
    private function unPrefix(string $value)
    {
        return substr($value, 1);
    }

    /**
     * Return Dijkstra's instance
     * @return \Diolan12\Dijkstra
     */
    public static function instance($graph = [])
    {
        return new self($graph);
    }

    /**
     * Add a vertex to the graph with its neighboring edges.
     *
     * @param string $name The name of the vertex.
     * @param array $edges An associative array representing the neighboring vertices and their edge weights.
     * @return \Diolan12\Dijkstra
     */
    public function addVertex($name, $edges)
    {
        $prefixedName = [];

        foreach ($edges as $key => $value) {
            if (gettype($value) == 'array') {
                $prefixedName[$this->setPrefix($key)] = $value['weight'];

                $this->edges[$this->setPrefix($name)][$this->setPrefix($key)] = [
                    'tag' => (isset($value['tag'])) ? $value['tag'] : ($name . ' to ' . $key),
                    'data' => (isset($value['data'])) ? $value['data'] : [],
                    'weight' => $value['weight']
                ];
            }

            else {
                $prefixedName[$this->setPrefix($key)] = $value;
                $this->edges[$this->setPrefix($name)][$this->setPrefix($key)] = [
                    'tag' => ($name . ' to ' . $key),
                    'data' => [],
                    'weight' => $value
                ];
            }
        }
        $this->vertices[$this->setPrefix($name)] = $prefixedName;

        return $this;
    }

    /**
     * Add an edge between two vertices with a given weight.
     *
     * @param string $src The source vertex.
     * @param string $dest The destination vertex.
     * @param int $weight The weight or cost of the edge.
     * @return \Diolan12\Dijkstra
     */
    public function addEdge($src, $dest, $weight, ?string $tag = null, array $data = [], $reversible = false)
    {
        $this->vertices[$this->setPrefix($src)][$this->setPrefix($dest)] = $weight;
        if ($reversible) {
            $this->vertices[$this->setPrefix($dest)][$this->setPrefix($src)] = $weight;

            $this->edges[$this->setPrefix($dest)][$this->setPrefix($src)] = [
                'tag' => $tag ?? ($dest . ' to ' . $src),
                'data' => $data,
                'weight' => $weight
            ];
        }
        return $this;
    }

    /**
     * Dijkstra's shortest path algorithm
     * [Wikipedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
     * @see https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
     * @throws \Diolan12\NoPathException
     */
    public function findShortestPath($start, $end, $verbose = false)
    {
        $start = $this->setPrefix($start);
        $end = $this->setPrefix($end);
        $distances = [];
        $visited = [];
        $previous = [];

        foreach ($this->vertices as $vertex => $edges) {
            $distances[$vertex] = INF;
            $visited[$vertex] = false;
            $previous[$vertex] = null;
        }

        $distances[$start] = 0;

        if (!isset($visited[$end])) {
            throw new NoPathException('Route not found "' . $this->unPrefix($end) . '"');
        }
        while ($visited[$end] === false) {
            $current = null;
            $minDist = INF;

            foreach ($distances as $vertex => $dist) {
                if (array_key_exists($vertex, $visited)){
                    if ($visited[$vertex] === false && $dist <= $minDist) {
                        $minDist = $dist;
                        $current = $vertex;
                    }
                } else throw new NoPathException('Edge "' . $this->unPrefix($vertex) . '" not found');
            }

            foreach ($this->vertices[$current] as $neighbor => $cost) {
                $alt = $distances[$current] + $cost;

                if ($alt < $distances[$neighbor]) {
                    $distances[$neighbor] = $alt;
                    $previous[$neighbor] = $current;
                }
            }

            $visited[$current] = true;
        }

        $path = [];
        $current = $end;

        while ($current !== $start) {
            if ($current == null) {
                throw new NoPathException('Route not found "' . $this->unPrefix($end) . '"');
            }
            array_unshift($path, $current);
            $current = $previous[$current];
        }

        array_unshift($path, $start);

        foreach ($path as $k => $p) {
            $path[$k] = $this->unPrefix($p);
        }

        if (!$verbose) return $path;
        else {
            // cost and steps setup
            $cost = 0;
            $edges = [];
            $merged = [];

            // figure out all the routings
            foreach (range(0, sizeof($path)-2) as $i) {
                $edges[] = $this->edges[$this->setPrefix($path[$i])][$this->setPrefix($path[$i+1])];
                $cost += $this->vertices[$this->setPrefix($path[$i])][$this->setPrefix($path[$i+1])];

                if ($i == 0) $merged[] = $path[$i];
                $merged[] = $this->edges[$this->setPrefix($path[$i])][$this->setPrefix($path[$i+1])];
                if ($i != sizeof($path)-2) $merged[] = $path[$i+1];
                if ($i == sizeof($path)-2) $merged[] = $path[$i+1];
            }

            return [
                'cost' => $cost,
                'edges' => $edges,
                'path' => $path,
                'merged' => $merged
            ];
        }
    }
}
